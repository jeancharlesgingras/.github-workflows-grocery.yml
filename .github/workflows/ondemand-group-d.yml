name: OnDemand-Group-D

on:
  schedule:
    - cron: '10 0 * * *' # 00:10 UTC = 19:10 Eastern (Toronto) during standard time
  workflow_dispatch:

concurrency:
  group: ondemand
  cancel-in-progress: false

jobs:
  run_cat_group_d:
    runs-on: ubuntu-latest
    steps:
      - name: Run 5 categories (limit=650, 60 min spacing)
        shell: bash
        run: |
          set -euo pipefail

          LIMIT=650
          SLEEP_SECONDS=$((60*60))  # 60 minutes

          declare -a cats=(
            "Office Products"
            "Pet Supplies"
            "Sports & Outdoors"
            "Tools & Home Improvement"
            "Toys & Games"
          )

          failures=0
          echo "Total categories: ${#cats[@]}"
          echo "Limit: $LIMIT"

          for i in "${!cats[@]}"; do
            cat="${cats[$i]}"
            slug=$(python3 -c 'import urllib.parse,sys;print(urllib.parse.quote(sys.argv[1]))' "$cat")
            resp_file="/tmp/resp_${i}.txt"

            echo "--------------------------------------------------"
            echo "[$(date -u)] ($((i+1))/${#cats[@]}) calling: $cat (limit=$LIMIT)"
            echo "URL: ${{ secrets.OND_WEBAPP }}?secret=***&task=$slug&limit=$LIMIT"

            http_code=$(
              curl -sS -L --max-redirs 5 --fail-with-body \
                -o "$resp_file" -w "%{http_code}" \
                "${{ secrets.OND_WEBAPP }}?secret=${{ secrets.OND_SECRET }}&task=$slug&limit=$LIMIT" \
              || echo "000"
            )

            echo "HTTP: $http_code"
            echo "Response (first 300 chars):"
            head -c 300 "$resp_file" || true
            echo ""
            echo "Response (last 50 lines):"
            tail -n 50 "$resp_file" || true

            if [[ "$http_code" != "200" ]]; then
              echo "::warning::HTTP $http_code for '$cat'"
              failures=$((failures+1))
            else
              if grep -qiE "error|unauthorized|missing task|unknown task|see executions log|no best-seller asins|no items remain|no fba items remain" "$resp_file"; then
                echo "::warning::Body indicates failure/empty results for '$cat'"
                failures=$((failures+1))
              fi
            fi

            if [[ $i -lt $((${#cats[@]}-1)) ]]; then
              echo "Sleeping ${SLEEP_SECONDS}s..."
              sleep "$SLEEP_SECONDS"
            fi
          done

          echo "--------------------------------------------------"
          echo "Finished. failures=$failures"
          [[ $failures -eq 0 ]] || exit 1
